/**
 * Core Philosophy: This ruleset establishes a secure-by-default model for an educational testing platform.
 * It assumes all users must be authenticated to perform any write actions. Publicly accessible curriculum
 * data (Subjects, Tests, Questions) is readable by anyone, but write operations are locked down, awaiting
 * the implementation of an administrative role. User-specific data (Students, Sessions) is strictly
 * private, accessible only by the owning user.
 *
 * Data Structure: The data is organized into a flat structure with top-level collections for `subjects`,
 * `tests`, `questions`, `students`, and `sessions`. This segregation allows for clear and distinct security
 * rules for each data type.
 *
 * Key Security Decisions:
 * - User Isolation: A user can only access their own student profile and session data. Listing other users'
 *   data is strictly forbidden to prevent data leakage and user enumeration.
 * - Public Curriculum, Protected Writes: Curriculum content like subjects, tests, and questions is publicly
 *   readable to allow any app user to view test materials. However, creating, updating, or deleting this
 *   content is prohibited by default, as these actions should be reserved for administrators (a role not
 *   yet defined in the model). TODO comments are placed to highlight where these admin-only rules should be added.
 * - Ownership Enforcement: For user-created data (`sessions`), ownership is established at creation by locking
 *   the `studentId` field to the creator's user ID. This ownership is immutable and is checked on all subsequent
 *   read and write operations.
 *
 * Denormalization for Authorization: The `studentId` field is denormalized onto each `session` document. This
 * allows for a direct and performant security check (`resource.data.studentId == request.auth.uid`) without needing
 * costly `get()` or `exists()` calls to other documents, simplifying the authorization logic significantly.
 *
 * Structural Segregation: There are no mixed public/private collections in this model. Data is segregated into
 * either fully public-read collections (`subjects`, `tests`, `questions`) or fully private, user-owned collections
 * (`students`, `sessions`), which is a secure and efficient design.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ------------------------------------------------------------------
    // Helper Functions
    // ------------------------------------------------------------------

    /**
     * Returns true if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Returns true if the authenticated user's UID matches the provided userId.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Returns true if the document being accessed already exists.
     * Used to protect against updates or deletes on non-existent documents.
     */
    function isExistingDoc() {
      return resource != null;
    }

    /**
     * Returns true if the user is the owner of an existing document.
     * A standard check for update and delete operations.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && isExistingDoc();
    }

    /**
     * On create, validates that the incoming session's studentId matches the creator's UID.
     */
    function isCreatingOwnSession() {
      return isSignedIn() && request.resource.data.studentId == request.auth.uid;
    }

    /**
     * On update, ensures the session's studentId cannot be changed.
     */
    function isSessionStudentIdImmutable() {
      return request.resource.data.studentId == resource.data.studentId;
    }

    /**
     * Returns true if the user is the owner of an existing session document.
     */
    function isExistingSessionOwner() {
      return isOwner(resource.data.studentId) && isExistingDoc();
    }


    /**
     * @description Publicly readable curriculum data. Writes are disabled pending an admin role.
     * @path /subjects/{subjectId}
     * @allow (get) Any user, signed in or not, can read a subject.
     * @deny (create) No user can create a subject, as this is an admin-only action.
     * @principle Public Read with Owner-Only Writes. Writes are disabled because the 'Subject' entity is missing an 'ownerId' or 'adminId' field for authorization.
     */
    match /subjects/{subjectId} {
      allow get, list: if true;
      // CRITICAL: Cannot implement owner-only writes. The 'Subject' entity is missing an 'ownerId' or 'authorId' field.
      allow create, update, delete: if false; // TODO: Add admin validation once an admin role is defined in the data model.
    }

    /**
     * @description Publicly readable test data. Writes are disabled pending an admin role.
     * @path /tests/{testId}
     * @allow (list) Any user, signed in or not, can list all tests.
     * @deny (update) No user can update a test, as this is an admin-only action.
     * @principle Public Read with Owner-Only Writes. Writes are disabled because the 'Test' entity is missing an 'ownerId' or 'authorId' field for authorization.
     */
    match /tests/{testId} {
      allow get, list: if true;
      // CRITICAL: Cannot implement owner-only writes. The 'Test' entity is missing an 'ownerId' or 'authorId' field.
      allow create, update, delete: if false; // TODO: Add admin validation once an admin role is defined in the data model.
    }

    /**
     * @description User-specific session data. A user can only access their own sessions.
     * @path /sessions/{sessionId}
     * @allow (create) A signed-in user can create a session for themselves (request.resource.data.studentId == auth.uid).
     * @deny (get) A user cannot read a session belonging to another student.
     * @principle Enforces document ownership for all operations based on the 'studentId' field.
     */
    match /sessions/{sessionId} {
      allow get: if isOwner(resource.data.studentId);
      allow list: if false; // Deny by default to prevent listing all user sessions. Use client-side queries with 'where("studentId", "==", auth.uid)'.
      allow create: if isCreatingOwnSession();
      allow update: if isExistingSessionOwner() && isSessionStudentIdImmutable();
      allow delete: if isExistingSessionOwner();
    }

    /**
     * @description Private user profile data. A user can only create and manage their own profile.
     * @path /students/{studentId}
     * @allow (create) A new user can create their own student profile (e.g., at /students/USER_UID).
     * @deny (get) User 'A' cannot read the student profile of user 'B'.
     * @deny (list) Listing all students is forbidden to prevent user enumeration.
     * @principle Restricts access to a user's own data tree, enforcing both privacy and ownership.
     */
    match /students/{studentId} {
      allow get: if isOwner(studentId);
      allow list: if false; // Disallow listing all students to protect user privacy.
      allow create: if isOwner(studentId) && request.resource.data.id == studentId;
      allow update: if isExistingOwner(studentId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(studentId);
    }

    /**
     * @description Publicly readable question data. Writes are disabled pending an admin role.
     * @path /questions/{questionId}
     * @allow (get) Any user, signed in or not, can read a question.
     * @deny (delete) No user can delete a question, as this is an admin-only action.
     * @principle Public Read with Owner-Only Writes. Writes are disabled because the 'Question' entity is missing an 'ownerId' or 'authorId' field for authorization.
     */
    match /questions/{questionId} {
      allow get, list: if true;
      // CRITICAL: Cannot implement owner-only writes. The 'Question' entity is missing an 'ownerId' or 'authorId' field.
      allow create, update, delete: if false; // TODO: Add admin validation once an admin role is defined in the data model.
    }
  }
}